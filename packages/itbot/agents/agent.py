import asyncio
from abc import ABC, abstractmethod
import os
import joblib
from typing import Dict, List, Optional

import pandas as pd
from packages.itbot.itbot import Signal
import threading
import logging
from trade_flow.common.logging import Logger


class Agent(ABC):
    """
    Abstract base class for agent interfaces responsible for loading trained models and generating trading signals.
    The agent continuously waits for data and sends signals asynchronously as an event-driven program.
    """

    def __init__(
        self,
        selected_symbols: List[str] = ["EURUSD", "BTCUSD", "XAUUSD"],
        logger: Optional[Logger] = None,
    ):
        """Initialize the trading bot with logging and a list of trading symbols.

        Args:
            selected_symbols (List[str]): List of symbols to trade. Default is ["EURUSD", "BTCUSD","XAUUSD"].
            logger (Optional[Logger]): An optional logger instance. If not provided, a default logger will be created.
        """
        # Set up logging
        self.logger = logger or Logger(name="it_bot", level=logging.DEBUG, filename="ITBot.log")

        # Initialize the signal queue for asynchronous handling
        self.signals_queue = asyncio.Queue()

        # Initialize the event loop
        self.loop = asyncio.get_event_loop()  # Use the current event loop

        # Store the selected symbols for trading
        self.selected_symbols = selected_symbols
        self.models = {
            symbol: None for symbol in self.selected_symbols
        }  # Initialize models for symbols

        # Log the initialized symbols
        self.logger.debug(f"Initialized with symbols: {self.selected_symbols}")

    def load_models(self, model_path: str) -> None:
        """
        Load the trained models from the specified path.

        Args:
            model_path (str): The directory path where the trained models are stored.

        Raises:
            ValueError: If the provided path is not a directory or if the model file is not found.
        """
        # Check if the provided path is a valid directory
        if not os.path.isdir(model_path):
            raise ValueError(f"The provided path '{model_path}' is not a valid directory.")

        # Load models for each symbol from the specified directory
        for symbol in self.selected_symbols:
            model_file = os.path.join(
                model_path, f"{symbol}_voting.joblib"
            )  # Adjust the file naming as needed

            # Check if the model file exists
            if os.path.isfile(model_file):
                try:
                    self.models[symbol] = joblib.load(model_file)
                    self.logger.info(f"Model for {symbol} loaded successfully from {model_file}.")
                except Exception as e:
                    self.logger.error(f"Error loading model for {symbol}: {e}")
            else:
                self.logger.warning(f"No model file found for {symbol} at {model_file}.")

    @abstractmethod
    async def generate_signals(self, symbol: str, data: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals using the loaded model and input data.

        Args:
            symbol (str): The trading symbol for which signals are being generated.
            data (pd.DataFrame): The input data used by the agent to make trading decisions.

        Returns:
            List[Signal]: A list of trading signals generated by the model.
        """
        pass

    async def add_data(self, data: dict) -> None:
        """
        Add data to the agent to trigger signal generation. This acts as an event to push new data.

        Args:
            data (dict): The data for generating signals.
        """
        await self.signals_queue.put(data)

    async def send_signals(self, signals: List[Signal]) -> None:
        """
        Asynchronously send the generated signals to ITBot.

        Args:
            signals (List[Signal]): The generated signals to be sent.
        """
        for signal in signals:
            self.logger.info(f"Sending signal: {signal}")
            await asyncio.sleep(0.1)

    async def _run_tasks(self) -> None:
        """
        Asynchronously wait for data, generate signals, and send them. This keeps running in the event loop.
        """
        while True:
            data = await self.signals_queue.get()
            signals = await self.generate_signals(data)
            await self.send_signals(signals)

    def _start_event_loop(self) -> None:
        """
        Start the event loop in the background using `asyncio.create_task`.
        This allows the agent to run without blocking the main thread.
        """
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.loop.create_task(self._run_tasks())  # Schedule _run_tasks in the background
        self.loop.run_forever()  # Keep the event loop running indefinitely

    def run(self) -> None:
        """
        Start the event loop in a separate thread, allowing the agent to process signals in the background.
        """
        self.logger.debug("Running Agent")
        thread = threading.Thread(target=self._start_event_loop, daemon=True)
        thread.start()
