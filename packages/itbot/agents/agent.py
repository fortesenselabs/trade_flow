import asyncio
from abc import ABC, abstractmethod
from typing import Dict, List, Optional

import pandas as pd
from packages.itbot.itbot import Signal
import threading
import logging
from trade_flow.common.logging import Logger


class Agent(ABC):
    """
    Abstract base class for agent interfaces responsible for loading trained models and generating trading signals.
    The agent continuously waits for data and sends signals asynchronously as an event-driven program.
    """

    def __init__(self, logger: Optional[Logger] = None):
        # Set up logging
        self.logger = logger or Logger(name="it_bot", log_level=logging.DEBUG, filename="ITBot.log")

        self.model = None
        self.signals_queue = asyncio.Queue()
        self.loop = None

        self.selected_symbols = ["BTCUSD", "EURUSD", "XAUUSD"]  # List of symbols you want to trade

    @abstractmethod
    def load_model(self, model_path: str) -> None:
        """
        Load the trained model from the specified path.

        Args:
            model_path (str): The file path of the trained model.
        """
        pass

    @abstractmethod
    async def generate_signals(self, symbol: str, data: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals using the loaded model and input data.

        Args:
            symbol (str): The trading symbol for which signals are being generated.
            data (pd.DataFrame): The input data used by the agent to make trading decisions.

        Returns:
            List[Signal]: A list of trading signals generated by the model.
        """
        pass

    async def add_data(self, data: dict) -> None:
        """
        Add data to the agent to trigger signal generation. This acts as an event to push new data.

        Args:
            data (dict): The data for generating signals.
        """
        await self.signals_queue.put(data)

    async def send_signals(self, signals: List[Signal]) -> None:
        """
        Asynchronously send the generated signals to ITBot.

        Args:
            signals (List[Signal]): The generated signals to be sent.
        """
        for signal in signals:
            self.logger.info(f"Sending signal: {signal}")
            await asyncio.sleep(0.1)

    async def _run_tasks(self) -> None:
        """
        Asynchronously wait for data, generate signals, and send them. This keeps running in the event loop.
        """
        while True:
            data = await self.signals_queue.get()
            signals = await self.generate_signals(data)
            await self.send_signals(signals)

    def _start_event_loop(self) -> None:
        """
        Start the event loop in the background using `asyncio.create_task`.
        This allows the agent to run without blocking the main thread.
        """
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.loop.create_task(self._run_tasks())  # Schedule _run_tasks in the background
        self.loop.run_forever()  # Keep the event loop running indefinitely

    def run(self) -> None:
        """
        Start the event loop in a separate thread, allowing the agent to process signals in the background.
        """
        self.logger.debug("Running Agent")
        thread = threading.Thread(target=self._start_event_loop, daemon=True)
        thread.start()
